---
title: Aufheben des Schutzes von Nutzlasten, die in ASP.NET Core, deren Schlüssel gesperrt wurden
author: rick-anderson
description: Informationen Sie zum Aufheben des Schutzes von Daten, die mit den Schlüsseln, die seit, in einer ASP.NET Core-app gesperrt wurden geschützt.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
uid: security/data-protection/consumer-apis/dangerous-unprotect
ms.openlocfilehash: b93ab0fa650041afdfaf1ed5572cc7e081bba244
ms.sourcegitcommit: 4d74644f11e0dac52b4510048490ae731c691496
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/25/2018
ms.locfileid: "50089349"
---
# <a name="unprotect-payloads-whose-keys-have-been-revoked-in-aspnet-core"></a><span data-ttu-id="45983-103">Aufheben des Schutzes von Nutzlasten, die in ASP.NET Core, deren Schlüssel gesperrt wurden</span><span class="sxs-lookup"><span data-stu-id="45983-103">Unprotect payloads whose keys have been revoked in ASP.NET Core</span></span>


<a name="data-protection-consumer-apis-dangerous-unprotect"></a>

<span data-ttu-id="45983-104">Die ASP.NET Core die Datenschutz-APIs sind in erster Linie für unbestimmte Persistenz vertrauliche Nutzlasten nicht vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="45983-104">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="45983-105">Andere Technologien wie [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) und [Azure Rights Management](/rights-management/) eignen sich besser für das Szenario unbegrenzten Speicher, und dementsprechend sichere schlüsselverwaltung Funktionen haben.</span><span class="sxs-lookup"><span data-stu-id="45983-105">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="45983-106">Allerdings nichts verbietet Entwickler mithilfe der ASP.NET Core die Datenschutz-APIs für den langfristigen Schutz von vertraulichen Daten.</span><span class="sxs-lookup"><span data-stu-id="45983-106">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span> <span data-ttu-id="45983-107">Schlüssel aus dem Schlüsselbund also nie entfernt `IDataProtector.Unprotect` vorhandene Nutzlasten können immer wiederhergestellt werden, solange die Schlüssel verfügbar und gültig sind.</span><span class="sxs-lookup"><span data-stu-id="45983-107">Keys are never removed from the key ring, so `IDataProtector.Unprotect` can always recover existing payloads as long as the keys are available and valid.</span></span>

<span data-ttu-id="45983-108">Allerdings ein Problem tritt auf, wenn der Entwickler versucht, Daten, die mit einem gesperrten Schlüssel als geschützt wurden, deren Schutz aufheben `IDataProtector.Unprotect` wird in diesem Fall eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="45983-108">However, an issue arises when the developer tries to unprotect data that has been protected with a revoked key, as `IDataProtector.Unprotect` will throw an exception in this case.</span></span> <span data-ttu-id="45983-109">Dies kann für kurzzeitiger oder vorübergehender Nutzlasten (z. B.-Authentifizierungstoken), in Ordnung sein, diese Arten von Nutzlasten leicht vom System erstellt werden können, und im schlimmsten Fall der Besucher der Website erforderlich sein, sich erneut anmelden.</span><span class="sxs-lookup"><span data-stu-id="45983-109">This might be fine for short-lived or transient payloads (like authentication tokens), as these kinds of payloads can easily be recreated by the system, and at worst the site visitor might be required to log in again.</span></span> <span data-ttu-id="45983-110">Aber für persistente Nutzlasten mit `Unprotect` Throw zu nicht akzeptablen Datenverlust führen kann.</span><span class="sxs-lookup"><span data-stu-id="45983-110">But for persisted payloads, having `Unprotect` throw could lead to unacceptable data loss.</span></span>

## <a name="ipersisteddataprotector"></a><span data-ttu-id="45983-111">IPersistedDataProtector</span><span class="sxs-lookup"><span data-stu-id="45983-111">IPersistedDataProtector</span></span>

<span data-ttu-id="45983-112">Zur Unterstützung der Szenarios ermöglichen-Nutzlasten, um auch bei widerrufenen Schlüssel ungeschützt sein System zum Schutz von Daten enthält eine `IPersistedDataProtector` Typ.</span><span class="sxs-lookup"><span data-stu-id="45983-112">To support the scenario of allowing payloads to be unprotected even in the face of revoked keys, the data protection system contains an `IPersistedDataProtector` type.</span></span> <span data-ttu-id="45983-113">Um eine Instanz der `IPersistedDataProtector`, rufen Sie einfach eine Instanz des `IDataProtector` in die normale Art und Weise und versuchen Sie es Umwandlung der `IDataProtector` zu `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="45983-113">To get an instance of `IPersistedDataProtector`, simply get an instance of `IDataProtector` in the normal fashion and try casting the `IDataProtector` to `IPersistedDataProtector`.</span></span>

> [!NOTE]
> <span data-ttu-id="45983-114">Nicht alle `IDataProtector` Instanzen umgewandelt werden können, um `IPersistedDataProtector`.</span><span class="sxs-lookup"><span data-stu-id="45983-114">Not all `IDataProtector` instances can be cast to `IPersistedDataProtector`.</span></span> <span data-ttu-id="45983-115">Entwickler sollten verwenden die C# als Operator oder ähnliche Laufzeitausnahmen zu vermeiden, die durch ungültig wandelt verursacht, und sie sollten darauf vorbereitet sein, der Fehler entsprechend behandeln.</span><span class="sxs-lookup"><span data-stu-id="45983-115">Developers should use the C# as operator or similar to avoid runtime exceptions caused by invalid casts, and they should be prepared to handle the failure case appropriately.</span></span>

<span data-ttu-id="45983-116">`IPersistedDataProtector` Stellt die folgende API-Oberfläche:</span><span class="sxs-lookup"><span data-stu-id="45983-116">`IPersistedDataProtector` exposes the following API surface:</span></span>

```csharp
DangerousUnprotect(byte[] protectedData, bool ignoreRevocationErrors,
     out bool requiresMigration, out bool wasRevoked) : byte[]
```

<span data-ttu-id="45983-117">Diese API wird die geschützte Nutzlast (als Bytearray) und gibt zurück, die nicht geschützte Nutzlast.</span><span class="sxs-lookup"><span data-stu-id="45983-117">This API takes the protected payload (as a byte array) and returns the unprotected payload.</span></span> <span data-ttu-id="45983-118">Es ist keine Zeichenfolge basierende Überladung.</span><span class="sxs-lookup"><span data-stu-id="45983-118">There's no string-based overload.</span></span> <span data-ttu-id="45983-119">Die beiden out-Parameter lauten wie folgt aus.</span><span class="sxs-lookup"><span data-stu-id="45983-119">The two out parameters are as follows.</span></span>

* <span data-ttu-id="45983-120">`requiresMigration`: Festlegung auf true fest, wenn der Schlüssel zum Schützen dieser Nutzlast ist nicht mehr den aktiven Standardschlüssel, z. B. der Schlüssel verwendet, um diese Nutzlast schützen alten und ein Schlüssel mit dem parallelen Vorgang, seitdem hat gelangen direkt.</span><span class="sxs-lookup"><span data-stu-id="45983-120">`requiresMigration`: will be set to true if the key used to protect this payload is no longer the active default key, e.g., the key used to protect this payload is old and a key rolling operation has since taken place.</span></span> <span data-ttu-id="45983-121">Der Aufrufer möchten möglicherweise sollten die Schritte zum erneuten Schützen der Nutzlast je nach ihren geschäftlichen Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="45983-121">The caller may wish to consider reprotecting the payload depending on their business needs.</span></span>

* <span data-ttu-id="45983-122">`wasRevoked`: wird auf true festgelegt werden, wenn der Schlüssel zum Schützen dieser Nutzlast aufgehoben wurde.</span><span class="sxs-lookup"><span data-stu-id="45983-122">`wasRevoked`: will be set to true if the key used to protect this payload was revoked.</span></span>

>[!WARNING]
> <span data-ttu-id="45983-123">Äußerste Vorsicht walten lassen beim Übergeben von `ignoreRevocationErrors: true` auf die `DangerousUnprotect` Methode.</span><span class="sxs-lookup"><span data-stu-id="45983-123">Exercise extreme caution when passing `ignoreRevocationErrors: true` to the `DangerousUnprotect` method.</span></span> <span data-ttu-id="45983-124">Wenn Sie nach einer Aufrufen dieser Methode die `wasRevoked` Wert ist "true", dann wurde der Schlüssel zum Schützen dieser Nutzlast gesperrt und der Nutzlast Authentizität als fehlerverdächtig behandelt werden soll.</span><span class="sxs-lookup"><span data-stu-id="45983-124">If after calling this method the `wasRevoked` value is true, then the key used to protect this payload was revoked, and the payload's authenticity should be treated as suspect.</span></span> <span data-ttu-id="45983-125">In diesem Fall den Vorgang nur fortsetzen Sie für die Nutzlast der ungeschützt ausgeführt wird, wenn Sie eine separate Assurance verfügen, z. B. authentisch ist, ist, dass es aus, die von einem nicht vertrauenswürdigen WebClient gesendet werden, statt einer sicheren Datenbank stammt.</span><span class="sxs-lookup"><span data-stu-id="45983-125">In this case, only continue operating on the unprotected payload if you have some separate assurance that it's authentic, e.g. that it's coming from a secure database rather than being sent by an untrusted web client.</span></span>

[!code-csharp[](dangerous-unprotect/samples/dangerous-unprotect.cs)]
